\documentclass[11pt]{article}

% Language setting
\usepackage[turkish]{babel}
\usepackage{pythonhighlight}

\usepackage[a4paper,top=2cm,bottom=2cm,left=2cm,right=2cm,marginparwidth=2cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{verbatim}
\usepackage{fancyhdr} % for header and footer
\usepackage{titlesec}
\usepackage{parskip}

\setlength{\parindent}{0pt}

\titleformat{\subsection}[runin]{\bfseries}{\thesubsection}{1em}{}

\pagestyle{fancy} % activate the custom header/footer

% define the header/footer contents
\lhead{\small{23BLM-4014 Yapay Sinir Ağları Ara Sınav Soru ve Cevap Kağıdı}}
\rhead{\small{Dr. Ulya Bayram}}
\lfoot{}
\rfoot{}

% remove header/footer on first page
\fancypagestyle{firstpage}{
  \lhead{}
  \rhead{}
  \lfoot{}
  \rfoot{\thepage}
}
 

\title{Çanakkale Onsekiz Mart Üniversitesi, Mühendislik Fakültesi, Bilgisayar Mühendisliği Akademik Dönem 2022-2023\\
Ders: BLM-4014 Yapay Sinir Ağları/Bahar Dönemi\\ 
ARA SINAV SORU VE CEVAP KAĞIDI\\
Dersi Veren Öğretim Elemanı: Dr. Öğretim Üyesi Ulya Bayram}
\author{%
\begin{minipage}{\textwidth}
\raggedright
Öğrenci Adı Soyadı: Bekircan Bozkurt\\ % Adınızı soyadınızı ve öğrenci numaranızı noktaların yerine yazın
Öğrenci No: 210401001
\end{minipage}%
}

\date{14 Nisan 2023}

\begin{document}
\maketitle

\vspace{-.5in}
\section*{Açıklamalar:}
\begin{itemize}
    \item Vizeyi çözüp, üzerinde aynı sorular, sizin cevaplar ve sonuçlar olan versiyonunu bu formatta PDF olarak, Teams üzerinden açtığım assignment kısmına yüklemeniz gerekiyor. Bu bahsi geçen PDF'i oluşturmak için LaTeX kullandıysanız, tex dosyasının da yer aldığı Github linkini de ödevin en başına (aşağı url olarak) eklerseniz bonus 5 Puan! (Tavsiye: Overleaf)
    \item Çözümlerde ya da çözümlerin kontrolünü yapmada internetten faydalanmak, ChatGPT gibi servisleri kullanmak serbest. Fakat, herkesin çözümü kendi emeğinden oluşmak zorunda. Çözümlerinizi, cevaplarınızı aşağıda belirttiğim tarih ve saate kadar kimseyle paylaşmayınız. 
    \item Kopyayı önlemek için Github repository'lerinizin hiçbirini \textbf{14 Nisan 2023, saat 15:00'a kadar halka açık (public) yapmayınız!} (Assignment son yükleme saati 13:00 ama internet bağlantısı sorunları olabilir diye en fazla ekstra 2 saat daha vaktiniz var. \textbf{Fakat 13:00 - 15:00 arası yüklemelerden -5 puan!}
    \item Ek puan almak için sağlayacağınız tüm Github repository'lerini \textbf{en geç 15 Nisan 2023 15:00'da halka açık (public) yapmış olun linklerden puan alabilmek için!}
    \item \textbf{14 Nisan 2023, saat 15:00'dan sonra gönderilen vizeler değerlendirilmeye alınmayacak, vize notu olarak 0 (sıfır) verilecektir!} Son anda internet bağlantısı gibi sebeplerden sıfır almayı önlemek için assignment kısmından ara ara çözümlerinizi yükleyebilirsiniz yedekleme için. Verilen son tarih/saatte (14 Nisan 2023, saat 15:00) sistemdeki en son yüklü PDF geçerli olacak.
    \item Çözümlerin ve kodların size ait ve özgün olup olmadığını kontrol eden bir algoritma kullanılacaktır. Kopya çektiği belirlenen vizeler otomatikman 0 (sıfır) alacaktır. Bu nedenle çözümlerinizi ve kodlarınızı yukarıda sağladığım gün ve saatlere kadar kimseyle paylaşmayınız.
    \item Bu vizeden alınabilecek en yüksek not 100'dür. Toplam aldığınız puan 100'ü geçerse, aldığınız not 100'e sabitlenecektir.
    \item LaTeX kullanarak PDF oluşturanlar öz geçmişlerine LaTeX bildiklerini de eklemeyi unutmasınlar :)
    \item Bu vizedeki soruların çözümleri ve tex dosyası için istediğiniz kadar sayıda Github repository'si oluşturabilirsiniz. Sadece yukarıda belirttiğim tarihlerde (14 Nisan 2023 saat 15:00 ile 15 Nisan 2023 saat 15:00 arasında) public yapmayı/halka açmayı ve Github profilinizi de öz geçmişinize eklemeyi unutmayın :)
    \item Bilgisayarınıza hiçbir program kurmadan, Overleaf, Google Colab, Kaggle gibi ortamlar üzerinden bu vizeyi tamamlamanız mümkün. İyi çalışmalar!!
\end{itemize}

(Ekstra 5 puan) \url{https://github.com/bekircanbozkurt/NeuralNetworksWorkspace/}

\newpage
\section{(Toplam 10 Puan) Hopfield Networks:}

\subsection{(2 Puan)} \textbf{ChatGPT’ye size Hopfield Network’ler ile ilgili detaylı bilgi vermesini isteyin. Sorduğunuz soruyu, ChatGPT'nin çıkartığı cevabı aşağı koyun. Bu cevapta anlamadığınız terimleri de ChatGPT’ye sorup, sorduğunuz soruları ve ChatGPT’nin verdiği cevapları da sırayla aşağı koyun.}

Hopfield ağları, bir sinir ağı türüdür ve adını John Hopfield'den almıştır. Hopfield ağları, verilen bir girdiye dayalı olarak bir sonuç üreten bir tür geri beslemeli ağdır. Bu ağlar, çeşitli optimizasyon problemlerinin çözümü için kullanılır.

Hopfield ağları, düğümlerden ve bağlantılardan oluşur. Düğümler, ağın girişini temsil eden nöronlardır ve her bir düğüm belirli bir değer alabilir. Bağlantılar, düğümler arasındaki ağırlıklardır ve ağın davranışını belirler. Hopfield ağları, düğümler arasındaki bağlantıların tamamen bağlantılı olduğu ve düğümlerin kendileri ile de bağlantılı olduğu bir ağ yapısına sahiptir.

Hopfield ağları, enerji fonksiyonlarını minimize etmek için kullanılır. Enerji fonksiyonu, ağın belirli bir durumundaki enerji düzeyini ölçer. Ağ, enerji fonksiyonunun minimum olduğu durumda karar verir. Hopfield ağları, en az enerjili duruma ulaşmak için yavaş yavaş enerjiyi azaltan bir dizi adım kullanır.

Hopfield ağları, çeşitli uygulamalarda kullanılabilir. Örneğin, bir Hopfield ağı, bir görüntünün parçalı olarak veya gürültülü bir şekilde verildiği bir durumda, eksik veya bozuk bölümleri tamamlamak için kullanılabilir. Ayrıca, Hopfield ağları, seyahat eden satıcı problemi, sıralama problemi, kümeleme problemi ve diğer optimizasyon problemlerini çözmek için de kullanılabilir.

Hopfield ağları, diğer sinir ağı türlerine kıyasla daha küçük boyutlu problemler için daha uygun olsa da, basit yapısı ve kolay uygulanabilirliği nedeniyle popüler bir sinir ağı türüdür.

\textit{Hopfield ağlarındaki düğümler arasındaki ağırlıklar ne anlama geliyor ?}

Hopfield ağlarındaki düğümler arasındaki ağırlıklar, ağın davranışını belirleyen önemli parametrelerdir. Her iki düğüm arasındaki ağırlık, bu düğümlerin birbiriyle olan etkileşimini belirtir. Ağırlıklar, Hopfield ağının enerji fonksiyonunu tanımlayan matrisin elemanlarıdır.

Daha spesifik olarak, iki düğüm arasındaki ağırlık, bir düğümün çıkışının diğer düğümün girdisine olan etkisini belirler. Ağırlıklar, çıkış ve girdi değerleri arasındaki ilişkiyi tanımlar ve her bir ağırlık, iki düğüm arasındaki bağlantının gücünü belirler.

Hopfield ağları, öğrenme yoluyla ağırlıkları öğrenebilir. Eğitim sırasında, ağa öğrenilecek örnekler verilir ve ağ, verilen örneklerin enerji fonksiyonlarının minimum olduğu ağırlıkları öğrenir. Bu öğrenme süreci, ağın daha sonra verilen benzer örnekleri tanımasına yardımcı olur.

Hopfield ağındaki ağırlıklar, ağın performansını doğrudan etkiler. Yanlış veya dengesiz ağırlıklar, ağın doğru çalışmasını engelleyebilir ve ağın enerji fonksiyonunu minimum değere ulaştıramayabilir. Bu nedenle, doğru ağırlıkların belirlenmesi, Hopfield ağı tasarımının önemli bir parçasıdır.

\textit{Hopfield ağları'nın enerjiyi azaltırken kullandığı adımlar nelerdir ?}

Hopfield ağları, enerji fonksiyonunu minimize etmek için yavaş yavaş enerjiyi azaltan bir dizi adım kullanır. Bu adımlar şunlardır:

İlk olarak, Hopfield ağına bir girdi verilir ve ağın her düğümü, girdinin bir parçasını temsil eder.

Düğümler arasındaki ağırlıklar kullanılarak, ağın enerji fonksiyonu hesaplanır. Enerji fonksiyonu, ağın belirli bir durumundaki enerji düzeyini ölçer.

Ağ, enerji fonksiyonunun minimum olduğu durumda karar verir. Eğer ağın mevcut enerji fonksiyonu minimuma eşitse, ağ işlemi durdurur ve sonucu üretir.

Eğer enerji fonksiyonu minimum değilse, ağdaki bir düğüm seçilir ve düğümün değeri değiştirilir. Düğümün değeri, enerji fonksiyonunun azalması için en uygun değere ayarlanır.

Düğümün değeri değiştirildikten sonra, ağdaki diğer düğümler arasındaki bağlantılar da güncellenir. Bu güncellemeler, enerji fonksiyonunu azaltmak için yapılır.

Ağın enerji fonksiyonu tekrar hesaplanır ve 3. adıma geri dönülür. Bu işlem, enerji fonksiyonu minimum değerine ulaşana kadar tekrarlanır.

Hopfield ağları, enerji fonksiyonunun minimum olduğu durumu bulmak için bu adımları yavaş yavaş uygulayarak ilerler. Bu sayede, ağın enerjisi minimum değere ulaşır ve ağın sonucu üretir.

\textit{Hopfield ağları'nın diğer sinir ağı türlerine kıyasla daha küçük boyutlu problemler için daha uygun olmasının nedeni nedir ?}

Hopfield ağları, diğer sinir ağı türlerine kıyasla daha küçük boyutlu problemler için daha uygun olmasının nedeni, ağ yapısının tam bağlantılı bir öğrenme ve hatırlama modeli olmasıdır. Hopfield ağları, birçok alanda kullanılan basit bir geri besleme sinir ağıdır ve her bir düğüm, diğer tüm düğümlerle doğrudan bağlantılıdır.

Bu yapı, her bir düğümün herhangi bir diğer düğümle etkileşime girmesine izin verir, bu da Hopfield ağlarının öğrenme ve hatırlama süreçlerinde yüksek bir bağlantı gücüne sahip olmasını sağlar. Ancak bu yapının dezavantajı, düğümler arasındaki bağlantı sayısının hızla artmasıdır, bu nedenle Hopfield ağları büyük ve karmaşık problemler için yetersiz kalabilir.

Öte yandan, diğer sinir ağı türleri, örneğin yapay sinir ağları (ANN) ve evrişimsel sinir ağları (CNN), büyük ve karmaşık problemler için daha uygundur. Bu sinir ağı türleri, öğrenme sürecinde düğümler arasındaki bağlantıların belirli bir desene göre ayarlandığı katmanlı bir yapıya sahiptir. Bu katmanlar, ağın daha fazla veri işleme kapasitesine sahip olmasını sağlar.

Sonuç olarak, Hopfield ağları, daha basit ve küçük boyutlu problemler için daha uygunken, diğer sinir ağı türleri, daha büyük ve karmaşık problemler için daha uygundur.

\subsection{(8 Puan)} \textbf{ChatGPT’nin açıklamalarından ne anladığınızı buraya kendi kelimelerinizle özetleyin. Örneğin ``Hopfield Network nedir? Ne işe yarar? Neden bilmemiz gerekir bunu? Gerçek hayatta kullanılıyor mu?'' gibi. Anlamadığınız kısımlar varsa ve ChatGPT’nin açıklamaları yeterli gelmezse internet dahil farklı kaynaklardan araştırıp, bilgilerin doğruluğunu sorgulamakta serbestsiniz. Konuyu doğru anlayıp anlamamanız puana etki edecektir. Kullandığınız kaynakları da belirtin!}

Yapay sinir ağı modelleri arasında basit ama etkili olan Hopfield ağları, geri beslemeli bir sinir ağıdır ve asıl amacı, verilen örneğe benzer örnekleri hatırlama ve geri çağırma işlemidir.

Hopfield ağları’nın basit olmasının temel nedeni her bir düğümün sadece “etkin veya etkisiz” olarak iki durumda olabilmesidir. Ayrıca bu ağlar, tam bağlantılı bir ağ yapısına sahip olduğu için düğümler arasındaki ağırlıkların hesaplanması kolaydır. Bundan dolayı diğer sinir ağı türlerine kıyasla daha küçük problemler için tercih edilir.

Her bir düğümün diğer düğümle etkileşime girmesi sayesinde Hopfield ağları öğrenme ve hatırlama süreçlerinde yüksek bir bağlantı gücüne sahip olur ancak düğümler arasındaki bağlantı sayısının hızla artması Hopfield ağlarının büyük ve karmaşık problemlerdeki yetersizliğine neden olur.

Hopfield ağları kendini yapay zeka ve sinir ağ modelleri konusunda geliştirmek isteyenler için oldukça önemlidir. Basit bir yapıya sahip olmasından dolayı yapay zeka ve sinir ağ modellerinin temellerini anlayabilmek için iyi bir tercihtir. Ayırca, sürekli erişim sağladığımız mobil cihazlar ve bunların en yaygın kimlik doğrulama seçeneği olan biyometrik doğrulama görevlerinde kullanılıyor olması nedeniyle bu ağ yapısı hakkında bilgi sahibi olmak oldukça yararlıdır.

\section{(Toplam 10 Puan) Boltzman Machine:}

\subsection{(2 Puan)} \textbf{ChatGPT’ye size Boltzman Machine ilgili detaylı bilgi vermesini isteyin. Sorduğunuz soruyu, ChatGPT'nin çıkartığı cevabı aşağı koyun. Bu cevapta anlamadığınız terimleri de ChatGPT’ye sorup, sorduğunuz soruları ve ChatGPT’nin verdiği cevapları da sırayla aşağı koyun.}

Boltzmann Machine, yapay sinir ağı modellerinden biridir ve özellikle olasılık tabanlı modellerde kullanılmaktadır. Bu model, 1980'lerde Geoffrey Hinton ve Terry Sejnowski tarafından geliştirilmiştir.

Boltzmann Machine, enerji fonksiyonu adı verilen bir hedef fonksiyonu kullanarak bir veri kümesindeki düzenliliği veya düzensizliği öğrenmeye çalışır. Enerji fonksiyonu, her bir örnek için bir enerji seviyesi hesaplar. Bu enerji seviyesi, modele özgü ağırlıkların ve örnek özelliklerinin birleşiminden hesaplanır.

Boltzmann Machine, iki tür düğümden oluşur: gizli ve gözlem düğümleri. Gözlem düğümleri, verilerin kendileridir ve ağın girişine doğrudan bağlıdırlar. Gizli düğümler, verilerin belirli özelliklerini temsil etmek için kullanılır. Ağdaki her düğümün etkin veya etkisiz olma durumu vardır.

Boltzmann Machine, öğrenme aşamasında iki farklı öğrenme yöntemi kullanır: sınır eğitimi ve çekişme öğrenmesi. Sınır eğitimi, ağı önceden tanımlanmış hedeflere uygun olarak öğrenir. Çekişme öğrenmesi ise, ağın belirli bir örnek kümesindeki desenleri tanımlamasına izin verir.

Boltzmann Machine, birçok alanda kullanılmaktadır. Özellikle, derin öğrenme ve yapay sinir ağı modellerinde sıkça kullanılır. Bunun yanı sıra, biyomedikal görüntü işlemede, doğal dil işlemede, robotikte ve müzikal kompozisyonlarda da kullanılmaktadır.

Boltzmann Machine, öğrenme sürecinde birçok hesaplama yapması gerektiğinden hesaplama yönünden oldukça yoğun bir modeldir. Ancak, bu modelin öğrenme yeteneği ve modelleme becerisi, özellikle büyük veri kümeleriyle çalışırken son derece yararlıdır.

\textit{Boltzmann Machine neden olasılık tabanlı modellerde kullanılmaktadır ?}

Boltzmann Machine olasılık tabanlı bir modeldir çünkü temelinde bir enerji fonksiyonu kullanarak olasılık hesaplaması yapar. Bu enerji fonksiyonu, sistemin içinde bulunduğu duruma göre bir enerji değeri atar. Sistemdeki her bir bileşenin durumu, bu enerji değerine katkı sağlar ve tüm bileşenlerin durumlarına bağlı olarak bir toplam enerji değeri hesaplanır. Bu enerji değeri, sistemin olasılık dağılımını belirleyen bir faktördür.

Boltzmann Machine, verilen girdilere dayalı olarak öğrenme ve tahmin yapabilen bir modeldir. Modelin öğrenme süreci, bir eğitim veri kümesindeki örneklerin özelliklerini ve ilişkilerini öğrenmek için gerçekleştirilir. Bu süreçte, sistemin içindeki bağlantı ağındaki ağırlıkların değerleri değiştirilir. Bu ağırlıklar, öğrenme süreci boyunca eğitim veri kümesindeki örneklerin tekrarlanan sunumlarına dayalı olarak ayarlanır.

Boltzmann Machine, birçok uygulama alanında kullanılabilir. Özellikle, görüntü tanıma, doğal dil işleme, öneri sistemleri ve sınıflandırma gibi alanlarda başarılı sonuçlar verir. Ayrıca, derin öğrenme modellerinin temel yapı taşlarından biri olarak da kullanılır.


\subsection{(8 Puan)} \textbf{ChatGPT’nin açıklamalarından ne anladığınızı buraya kendi kelimelerinizle özetleyin. Örneğin ``Boltzman Machine nedir? Ne işe yarar? Neden bilmemiz gerekir bunu? Gerçek hayatta kullanılıyor mu?'' gibi. Anlamadığınız kısımlar varsa ve ChatGPT’nin açıklamaları yeterli gelmezse internet dahil farklı kaynaklardan araştırıp, bilgilerin doğruluğunu sorgulamakta serbestsiniz. Konuyu doğru anlayıp anlamamanız puana etki edecektir. Kullandığınız kaynakları da belirtin!}

Boltzmann Machine, olasılık tabanlı modellerde kullanılan bir yapay sinir ağı modelidir. Bir veri setindeki düzenliliği veya düzensizliği öğrenmeye çalışır. Bunu enerji fonksiyonu isimli hedef foksiyonu kullanarak yapar. İki düğümden oluşanan Boltzmann Machine iki farklı öğrenme yöntemi kullanır. Bunlardan ilki olan sınır eğitimi, ağı önceden tanımlı hedeflere uygun öğrenme sağlar. Bir diğer öğrenme yöntemi olan çekişme öğrenmesi ise, ağın belirli bir örnek kümedeki desenleri tanımlamaya ve bunları taklit etmeye izin verir.

Öğrenme sürecinde birden fazla hesaplama yapan Boltzmann Machine, yoğun bir hesaplama süreci olduğu için ve öğrenme yeteneği, modelleme  açısından büyük veri setleriyle çalışırken iyi oldukça faydalıdır.

Birçok alanda kullanılan Boltzmann Machine, özellikle derin öğrenme ve yapay sinir ağı modellerinde sıkça kullanılmaktadır. Bunların yanı sıra, biyomedikal görüntü işlemede, doğal dil işlemede, robotikte ve müzikal kompozisyonlarda da kullanım alanları bulunmaktadır.



\section{(Toplam 10 Puan) Markov Assumption ve Markov Chain:}

\subsection{(2 Puan)} \textbf{ChatGPT’ye size Marakov assumption ve Markov Chain ilgili detaylı bilgi vermesini isteyin. Sorduğunuz soruyu, ChatGPT'nin çıkartığı cevabı aşağı koyun. Bu cevapta anlamadığınız terimleri de ChatGPT’ye sorup, sorduğunuz soruları ve ChatGPT’nin verdiği cevapları da sırayla aşağı koyun.}

Markov süreci, bir sistemin gelecekteki durumunun sadece mevcut durumuna bağlı olduğunu varsayan bir matematiksel modeldir. Bu varsayım, gelecekteki bir olayın sadece mevcut zamanda olan olaylara bağlı olduğunu kabul eder ve geçmiş olayların önemini yok sayar. Bu varsayım, birçok uygulamada kullanılır, örneğin finansal piyasalar, mühendislik, fizik ve doğal dil işleme gibi alanlarda.

Markov süreci, olası bir dizi durum arasındaki geçişlerin olasılıklarını tanımlayan bir süreçtir. Bu geçişler, bir durumdan diğerine geçiş olasılığına bağlıdır. Bu geçişlerin olasılıkları, Markov Zinciri olarak adlandırılan bir yapı içinde modellenebilir. Markov Zinciri, bir durumdan diğerine geçiş olasılıklarını içeren bir matrisle tanımlanır. Bu matris, geçiş olasılıklarının toplamına eşittir ve herhangi bir durumdan diğerine geçiş olasılıkları sadece o anki duruma bağlıdır.

Markov süreci ve Markov zinciri birçok alanda kullanılır. Örneğin, doğal dil işlemede, bir kelimenin bir sonraki kelimeye bağlı olduğunu varsayarak, kelime tahmininde kullanılabilirler. Finansal piyasalarda, bir varlığın fiyatının gelecekteki fiyatına sadece mevcut fiyatına bağlı olduğunu varsayarak, fiyat hareketleri tahmin edilebilir. Mühendislikte, bir sistemin gelecekteki durumunu tahmin etmek için kullanılabilirler.

\textit{Markov süreci neden geçmiş olayların önemini yok sayar ?}

Markov süreci, gelecekteki bir olayın sadece mevcut zamanda olan olaylara bağlı olduğunu varsayar ve geçmiş olayların önemini yok sayar. Bu varsayımın nedeni, bir Markov sürecinin "belleksiz" veya "belleksiz" olmasıdır. Yani, gelecekteki durumlar sadece mevcut duruma bağlıdır ve geçmiş durumlar ne olursa olsun, gelecekteki durumlar üzerinde herhangi bir etkisi yoktur.

Bu varsayım, birçok durumda gerçekçi değildir. Ancak bazı durumlarda, geçmiş olayların etkileri ihmal edilebilir düzeydedir ve Markov süreci modeli iyi bir yaklaşım olabilir. Örneğin, bir kelimenin bir sonraki kelimeye bağlı olduğu doğal dil işlemede, bir kelimenin anlamı bir sonraki kelimeye bağlı olabilir ve geçmiş kelimelerin anlamsal etkisi önemsiz olabilir.

Ancak, bazı durumlarda geçmiş olayların etkisi oldukça belirgindir ve Markov süreci modeli yetersiz kalabilir. Bu durumlarda, Markov sürecinin genişletilmiş veya geliştirilmiş versiyonları kullanılabilir. Örneğin, Markov zinciri varsayımını genişletmek için "bellekli" veya "bellekli" Markov süreçleri geliştirilmiştir, bu süreçler geçmiş olayların etkisini de dahil eder.


\subsection{(8 Puan)} \textbf{ChatGPT’nin açıklamalarından ne anladığınızı buraya kendi kelimelerinizle özetleyin. Örneğin ``Markov assumption ve Markov Chain nedir? Ne işe yarar? Neden bilmemiz gerekir bunu? Gerçek hayatta kullanılıyor mu?'' gibi. Anlamadığınız kısımlar varsa ve ChatGPT’nin açıklamaları yeterli gelmezse internet dahil farklı kaynaklardan araştırıp, bilgilerin doğruluğunu sorgulamakta serbestsiniz. Konuyu doğru anlayıp anlamamanız puana etki edecektir. Kullandığınız kaynakları da belirtin!}

Markov süreci, gelecekteki durumun o anki duruma bağlı olduğunu varsayar ve geçmiş olayların önemini yok sayar. Günümüzde finansal piyasalar, mühendislik, fizik ve doğal dil işleme alanında kullanılan bu varsayımın geçmiş olayların önemini yok saymasının nedeni Markov sürecinin “belleksiz” olmasından kaynaklıdır. Bu yaklaşım birçok durumda gerçekçi olmasada geçmiş olayların etkilerinin ihmal edilebilir olduğu durumlarda iyi bir yaklaşım olabilir. Mesela doğal dil işleme anlamında bir kelimenin anlamı ondan sonra gelecek olan kelimeye bağlı olabilir ve bu bağlamda geçmiş kelimelerin anlamsal etkisi önemsiz olabilir.

Markov süreci temelde durumlar arasındaki geçişlerin olasılıklarını tanımlayıp Markov zinciri adında bu olasılıkların matris halinde tanımladığı bir yapıda modeller. Bu matris geçiş olasılıklarının toplamına denktir.


\section{(Toplam 20 Puan) Feed Forward:}
 
\begin{itemize}
    \item Forward propagation için, input olarak şu X matrisini verin (tensöre çevirmeyi unutmayın):\\
    $X = \begin{bmatrix}
        1 & 2 & 3\\
        4 & 5 & 6
        \end{bmatrix}$
    Satırlar veriler (sample'lar), kolonlar öznitelikler (feature'lar).
    \item Bir adet hidden layer olsun ve içinde tanh aktivasyon fonksiyonu olsun
    \item Hidden layer'da 50 nöron olsun
    \item Bir adet output layer olsun, tek nöronu olsun ve içinde sigmoid aktivasyon fonksiyonu olsun
\end{itemize}

Tanh fonksiyonu:\\
$f(x) = \frac{exp(x) - exp(-x)}{exp(x) + exp(-x)}$
\vspace{.2in}

Sigmoid fonksiyonu:\\
$f(x) = \frac{1}{1 + exp(-x)}$

\vspace{.2in}
 \textbf{Pytorch kütüphanesi ile, ama kütüphanenin hazır aktivasyon fonksiyonlarını kullanmadan, formülünü verdiğim iki aktivasyon fonksiyonunun kodunu ikinci haftada yaptığımız gibi kendiniz yazarak bu yapay sinir ağını oluşturun ve aşağıdaki üç soruya cevap verin.}
 
\subsection{(10 Puan)} \textbf{Yukarıdaki yapay sinir ağını çalıştırmadan önce pytorch için Seed değerini 1 olarak set edin, kodu aşağıdaki kod bloğuna ve altına da sonucu yapıştırın:}

% Latex'de kod koyabilirsiniz python formatında. Aşağıdaki örnekleri silip içine kendi kodunuzu koyun
\begin{python}
import torch

# Seed degerimizi 1 olarak tanimliyoruz.
torch.manual_seed(1)

# Input olarak soruda belirtilen matrisi kullanip tensor haline getiriyoruz.
X = torch.tensor([[1, 2, 3], [4, 5, 6]]).float()

# Soruda istenilen uzere kendi Tanh fonksiyonumuzu tanimliyoruz.
def tanhFunc(x):

    return (torch.exp(x) - torch.exp(-x)) / (torch.exp(x) + torch.exp(-x))

# Soruda istenilen uzere kendi Sigmoid fonksiyonumuzu tanimliyoruz.
def sigmoidFunc(x):
    return 1 / (1 + torch.exp(-x))

class NeuralNetwork(torch.nn.Module):

    def __init__(self):
        super(NeuralNetwork, self).__init__()

        # Hidden layer burada tanimlaniyor.
        self.hidden_layer = torch.nn.Linear(3, 50)

        # Output layer burada tanimlaniyor.
        self.output_layer = torch.nn.Linear(50, 1)

    def forward(self, x):

        # Hidden layer ile Tanh fonksiyonu aktive ediliyor.
        hidden = tanhFunc(self.hidden_layer(x))
        # Output layer ile Sigmoid fonksiyonu aktive ediliyor.
        output = sigmoidFunc(self.output_layer(hidden))

        return output

# Kendi networkumuzu initialize ediyoruz.
net = NeuralNetwork()
output = net(X)

print(output)



\end{python}

tensor([[0.4892],[0.5566]], grad_fn=<MulBackward0>)


\subsection{(5 Puan)} \textbf{Yukarıdaki yapay sinir ağını çalıştırmadan önce Seed değerini öğrenci numaranız olarak değiştirip, kodu aşağıdaki kod bloğuna ve altına da sonucu yapıştırın:}

\begin{python}
import torch

# Seed degerimizi ogrenci numaramiz ile degistiriyoruz.
torch.manual_seed(210401001)

# Input olarak soruda belirtilen matrisi kullanip tensor haline getiriyoruz.
X = torch.tensor([[1, 2, 3], [4, 5, 6]]).float()

# Soruda istenilen uzere kendi Tanh fonksiyonumuzu tanimliyoruz.
def tanhFunc(x):

    return (torch.exp(x) - torch.exp(-x)) / (torch.exp(x) + torch.exp(-x))

# Soruda istenilen uzere kendi Sigmoid fonksiyonumuzu tanimliyoruz.
def sigmoidFunc(x):
    return 1 / (1 + torch.exp(-x))

class NeuralNetwork(torch.nn.Module):

    def __init__(self):
        super(NeuralNetwork, self).__init__()

        # Hidden layer burada tanimlaniyor.
        self.hidden_layer = torch.nn.Linear(3, 50)

        # Output layer burada tanimlaniyor.
        self.output_layer = torch.nn.Linear(50, 1)

    def forward(self, x):

        # Hidden layer ile Tanh fonksiyonu aktive ediliyor.
        hidden = tanhFunc(self.hidden_layer(x))
        # Output layer ile Sigmoid fonksiyonu aktive ediliyor.
        output = sigmoidFunc(self.output_layer(hidden))

        return output

# Kendi networkumuzu initialize ediyoruz.
net = NeuralNetwork()
output = net(X)

print(output)

\end{python}

tensor([[0.4312], [0.4450]], grad_fn=<MulBackward0>)

\subsection{(5 Puan)} \textbf{Kodlarınızın ve sonuçlarınızın olduğu jupyter notebook'un Github repository'sindeki linkini aşağıdaki url kısmının içine yapıştırın. İlk sayfada belirttiğim gün ve saate kadar halka açık (public) olmasın:}
% size ait Github olmak zorunda, bu vize için ayrı bir github repository'si açıp notebook'u onun içine koyun. Kendine ait olmayıp da arkadaşının notebook'unun linkini paylaşanlar 0 alacak.

\url{https://github.com/bekircanbozkurt/NeuralNetworksWorkspace}

\section{(Toplam 40 Puan) Multilayer Perceptron (MLP):} 
\textbf{Bu bölümdeki sorularda benim vize ile beraber paylaştığım Prensesi İyileştir (Cure The Princess) Veri Seti parçaları kullanılacak. Hikaye şöyle (soruyu çözmek için hikaye kısmını okumak zorunda değilsiniz):} 

``Bir zamanlar, çok uzaklarda bir ülkede, ağır bir hastalığa yakalanmış bir prenses yaşarmış. Ülkenin kralı ve kraliçesi onu iyileştirmek için ellerinden gelen her şeyi yapmışlar, ancak denedikleri hiçbir çare işe yaramamış.

Yerel bir grup köylü, herhangi bir hastalığı iyileştirmek için gücü olduğu söylenen bir dizi sihirli malzemeden bahsederek kral ve kraliçeye yaklaşmış. Ancak, köylüler kral ile kraliçeyi, bu malzemelerin etkilerinin patlayıcı olabileceği ve son zamanlarda yaşanan kuraklıklar nedeniyle bu malzemelerden sadece birkaçının herhangi bir zamanda bulunabileceği konusunda uyarmışlar. Ayrıca, sadece deneyimli bir simyacı bu özelliklere sahip patlayıcı ve az bulunan malzemelerin belirli bir kombinasyonunun prensesi iyileştireceğini belirleyebilecekmiş.

Kral ve kraliçe kızlarını kurtarmak için umutsuzlar, bu yüzden ülkedeki en iyi simyacıyı bulmak için yola çıkmışlar. Dağları tepeleri aşmışlar ve nihayet "Yapay Sinir Ağları Uzmanı" olarak bilinen yeni bir sihirli sanatın ustası olarak ün yapmış bir simyacı bulmuşlar.

Simyacı önce köylülerin iddialarını ve her bir malzemenin alınan miktarlarını, ayrıca iyileşmeye yol açıp açmadığını incelemiş. Simyacı biliyormuş ki bu prensesi iyileştirmek için tek bir şansı varmış ve bunu doğru yapmak zorundaymış. (Original source: \url{https://www.kaggle.com/datasets/unmoved/cure-the-princess})

(Buradan itibaren ChatGPT ve Dr. Ulya Bayram'a ait hikayenin devamı)

Simyacı, büyülü bileşenlerin farklı kombinasyonlarını analiz etmek ve denemek için günler harcamış. Sonunda birkaç denemenin ardından prensesi iyileştirecek çeşitli karışım kombinasyonları bulmuş ve bunları bir veri setinde toplamış. Daha sonra bu veri setini eğitim, validasyon ve test setleri olarak üç parçaya ayırmış ve bunun üzerinde bir yapay sinir ağı eğiterek kendi yöntemi ile prensesi iyileştirme ihtimalini hesaplamış ve ikna olunca kral ve kraliçeye haber vermiş. Heyecanlı ve umutlu olan kral ve kraliçe, simyacının prensese hazırladığı ilacı vermesine izin vermiş ve ilaç işe yaramış ve prenses hastalığından kurtulmuş.

Kral ve kraliçe, kızlarının hayatını kurtardığı için simyacıya krallıkta kalması ve çalışmalarına devam etmesi için büyük bir araştırma bütçesi ve çok sayıda GPU'su olan bir server vermiş. İyileşen prenses de kendisini iyileştiren yöntemleri öğrenmeye merak salıp, krallıktaki üniversitenin bilgisayar mühendisliği bölümüne girmiş ve mezun olur olmaz da simyacının yanında, onun araştırma grubunda çalışmaya başlamış. Uzun yıllar birlikte krallıktaki insanlara, hayvanlara ve doğaya faydalı olacak yazılımlar geliştirmişler, ve simyacı emekli olduğunda prenses hem araştırma grubunun hem de krallığın lideri olarak hayatına devam etmiş.

Prenses, kendisini iyileştiren veri setini de, gelecekte onların izinden gidecek bilgisayar mühendisi prensler ve prensesler başkalarına faydalı olabilecek yapay sinir ağları oluşturmayı öğrensinler diye halka açmış ve sınavlarda kullanılmasını salık vermiş.''

\textbf{İki hidden layer'lı bir Multilayer Perceptron (MLP) oluşturun beşinci ve altıncı haftalarda yaptığımız gibi. Hazır aktivasyon fonksiyonlarını kullanmak serbest. İlk hidden layer'da 100, ikinci hidden layer'da 50 nöron olsun. Hidden layer'larda ReLU, output layer'da sigmoid aktivasyonu olsun.}

\textbf{Output layer'da kaç nöron olacağını veri setinden bakıp bulacaksınız. Elbette bu veriye uygun Cross Entropy loss yöntemini uygulayacaksınız. Optimizasyon için Stochastic Gradient Descent yeterli. Epoch sayınızı ve learning rate'i validasyon seti üzerinde denemeler yaparak (loss'lara overfit var mı diye bakarak) kendiniz belirleyeceksiniz. Batch size'ı 16 seçebilirsiniz.}

\subsection{(10 Puan)} \textbf{Bu MLP'nin pytorch ile yazılmış class'ının kodunu aşağı kod bloğuna yapıştırın:}

\begin{python}
class MLP(nn.Module):
    def __init__(self, input_size, hidden_layer_size1, hidden_layer_size2, output_layer_size):
        super(MultilayerPerceptron, self).__init__()
        
        self.layer1 = nn.Linear(input_size, hidden_layer_size1)
        self.layer2 = nn.Linear(hidden_layer_size1, hidden_layer_size2)
        self.layer3 = nn.Linear(hidden_layer_size2, output_layer_size)
        
        self.relu = nn.ReLU()
        self.sigmoid = nn.Sigmoid()

    def forward(self, x):
        x = self.relu(self.layer1(x))
        x = self.relu(self.layer2(x))
        x = self.sigmoid(self.layer3(x))
        return x
        
input_size = 13     # Girdilerin boyutu
hidden_size1 = 100  # Hidden layer1'deki noron sayisi
hidden_size2 = 50   # Hidden layer2'deki noron sayisi
output_size = 1     # Cikis katmandaki noron sayisi

model = MLP(input_size, hidden_layer_size1, hidden_layer_size2, output_layer_size)
\end{python}

\subsection{(10 Puan)} \textbf{SEED=öğrenci numaranız set ettikten sonra altıncı haftada yazdığımız gibi training batch'lerinden eğitim loss'ları, validation batch'lerinden validasyon loss değerlerini hesaplayan kodu aşağıdaki kod bloğuna yapıştırın ve çıkan figürü de alta ekleyin.}

\begin{python}
kod_buraya = None
if kod_buraya:
    devam_ise_buraya = 0

print(devam_ise_buraya)
\end{python}

% Figure aşağıda comment içindeki kısımdaki gibi eklenir.
\begin{comment}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.75\textwidth]{mypicturehere.png}
    \caption{Buraya açıklama yazın}
    \label{fig:my_pic}
\end{figure}
\end{comment}

\subsection{(10 Puan)} \textbf{SEED=öğrenci numaranız set ettikten sonra altıncı haftada ödev olarak verdiğim gibi earlystopping'deki en iyi modeli kullanarak, Prensesi İyileştir test setinden accuracy, F1, precision ve recall değerlerini hesaplayan kodu yazın ve sonucu da aşağı yapıştırın. \%80'den fazla başarı bekliyorum test setinden. Daha düşükse başarı oranınız, nerede hata yaptığınızı bulmaya çalışın. \%90'dan fazla başarı almak mümkün (ben denedim).}

\begin{python}
kod_buraya = None
if kod_buraya:
    devam_ise_buraya = 0

print(devam_ise_buraya)
\end{python}

Sonuçlar buraya

\subsection{(5 Puan)} \textbf{Tüm kodların CPU'da çalışması ne kadar sürüyor hesaplayın. Sonra to device yöntemini kullanarak modeli ve verileri GPU'ya atıp kodu bir de böyle çalıştırın ve ne kadar sürdüğünü hesaplayın. Süreleri aşağıdaki tabloya koyun. GPU için Google Colab ya da Kaggle'ı kullanabilirsiniz, iki ortam da her hafta saatlerce GPU hakkı veriyor.}

\begin{table}[ht!]
    \centering
    \caption{Buraya bir açıklama yazın}
    \begin{tabular}{c|c}
        Ortam & Süre (saniye) \\\hline
        CPU & kaç? \\
        GPU & kaç?\\
    \end{tabular}
    \label{tab:my_table}
\end{table}

\subsection{(3 Puan)} \textbf{Modelin eğitim setine overfit etmesi için elinizden geldiği kadar kodu gereken şekilde değiştirin, validasyon loss'unun açıkça yükselmeye başladığı, training ve validation loss'ları içeren figürü aşağı koyun ve overfit için yaptığınız değişiklikleri aşağı yazın. Overfit, tam bir çanak gibi olmalı ve yükselmeli. Ona göre parametrelerle oynayın.}

Cevaplar buraya

% Figür aşağı
\begin{comment}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.75\textwidth]{mypicturehere.png}
    \caption{Buraya açıklama yazın}
    \label{fig:my_pic}
\end{figure}
\end{comment}

\subsection{(2 Puan)} \textbf{Beşinci soruya ait tüm kodların ve cevapların olduğu jupyter notebook'un Github linkini aşağıdaki url'e koyun.}

\url{https://github.com/bekircanbozkurt/NeuralNetworksWorkspace}

\section{(Toplam 10 Puan)} \textbf{Bir önceki sorudaki Prensesi İyileştir problemindeki yapay sinir ağınıza seçtiğiniz herhangi iki farklı regülarizasyon yöntemi ekleyin ve aşağıdaki soruları cevaplayın.} 

\subsection{(2 puan)} \textbf{Kodlarda regülarizasyon eklediğiniz kısımları aşağı koyun:} 

\begin{python}
kod_buraya = None
if kod_buraya:
    devam_ise_buraya = 0

print(devam_ise_buraya)
\end{python}

\subsection{(2 puan)} \textbf{Test setinden yeni accuracy, F1, precision ve recall değerlerini hesaplayıp aşağı koyun:}

Sonuçlar buraya.

\subsection{(5 puan)} \textbf{Regülarizasyon yöntemi seçimlerinizin sebeplerini ve sonuçlara etkisini yorumlayın:}

Yorumlar buraya.

\subsection{(1 puan)} \textbf{Sonucun github linkini  aşağıya koyun:}

\url{https://github.com/bekircanbozkurt/NeuralNetworksWorkspace}

\end{document}